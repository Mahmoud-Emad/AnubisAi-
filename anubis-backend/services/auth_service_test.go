package services

import (
	"testing"
	"time"

	"anubis-backend/config"
	"anubis-backend/database"
	"anubis-backend/models"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"gorm.io/gorm"
)

func setupTestDB(t *testing.T) *gorm.DB {
	cfg := &config.Config{
		Database: config.DatabaseConfig{
			Type: "sqlite",
			Host: ":memory:",
		},
		JWT: config.JWTConfig{
			Secret: "test-secret-key-for-testing-only",
			Expiry: 24 * time.Hour,
		},
		TFGrid: config.TFGridConfig{
			Network: "test",
		},
	}
	
	err := database.InitDatabase(cfg)
	require.NoError(t, err)
	
	err = database.RunMigrations()
	require.NoError(t, err)
	
	return database.GetDB()
}

func TestAuthService_Register_ExistingWallet(t *testing.T) {
	db := setupTestDB(t)
	defer func() {
		sqlDB, _ := db.DB()
		sqlDB.Close()
	}()

	cfg := &config.Config{
		JWT: config.JWTConfig{
			Secret: "test-secret-key-for-testing-only",
			Expiry: 24 * time.Hour,
		},
		TFGrid: config.TFGridConfig{
			Network: "test",
		},
	}

	authService := NewAuthService(cfg)

	// Test registration with existing wallet (mnemonic provided)
	req := &RegisterRequest{
		FirstName: "John",
		LastName:  "Doe",
		Email:     "john.doe@example.com",
		Password:  "securepassword123",
		Username:  "johndoe",
		Mnemonic:  "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about", // Valid BIP39 mnemonic
	}

	response, err := authService.Register(req)
	
	assert.NoError(t, err)
	assert.NotNil(t, response)
	assert.True(t, response.Success)
	assert.NotEmpty(t, response.Token)
	assert.NotNil(t, response.User)
	assert.NotNil(t, response.WalletInfo)
	assert.True(t, response.User.HasWallet) // Should be true for existing wallet
	assert.Equal(t, "john.doe@example.com", response.User.Email)
	assert.Equal(t, "test", response.User.Network)
	assert.NotNil(t, response.User.TwinID)

	// Verify user was created in database
	var user models.User
	err = db.Where("email = ?", req.Email).First(&user).Error
	assert.NoError(t, err)
	assert.Equal(t, req.FirstName, user.FirstName)
	assert.Equal(t, req.LastName, user.LastName)
	assert.True(t, user.HasWallet)
	assert.NotEmpty(t, user.WalletAddress)
}

func TestAuthService_Register_AutoGeneratedWallet(t *testing.T) {
	db := setupTestDB(t)
	defer func() {
		sqlDB, _ := db.DB()
		sqlDB.Close()
	}()

	cfg := &config.Config{
		JWT: config.JWTConfig{
			Secret: "test-secret-key-for-testing-only",
			Expiry: 24 * time.Hour,
		},
		TFGrid: config.TFGridConfig{
			Network: "test",
		},
	}

	authService := NewAuthService(cfg)

	// Test registration without mnemonic (auto-generated wallet)
	req := &RegisterRequest{
		FirstName: "Jane",
		LastName:  "Smith",
		Email:     "jane.smith@example.com",
		Password:  "anothersecurepass456",
		Username:  "janesmith",
		// No mnemonic provided - should auto-generate wallet
	}

	response, err := authService.Register(req)
	
	assert.NoError(t, err)
	assert.NotNil(t, response)
	assert.True(t, response.Success)
	assert.NotEmpty(t, response.Token)
	assert.NotNil(t, response.User)
	assert.NotNil(t, response.WalletInfo)
	assert.False(t, response.User.HasWallet) // Should be false for auto-generated wallet
	assert.Equal(t, "jane.smith@example.com", response.User.Email)
	assert.Equal(t, "test", response.User.Network)
	assert.NotNil(t, response.User.TwinID)

	// Verify user was created in database
	var user models.User
	err = db.Where("email = ?", req.Email).First(&user).Error
	assert.NoError(t, err)
	assert.Equal(t, req.FirstName, user.FirstName)
	assert.Equal(t, req.LastName, user.LastName)
	assert.False(t, user.HasWallet)
	assert.NotEmpty(t, user.WalletAddress)
}

func TestAuthService_Register_ValidationErrors(t *testing.T) {
	db := setupTestDB(t)
	defer func() {
		sqlDB, _ := db.DB()
		sqlDB.Close()
	}()

	cfg := &config.Config{
		JWT: config.JWTConfig{
			Secret: "test-secret-key-for-testing-only",
			Expiry: 24 * time.Hour,
		},
		TFGrid: config.TFGridConfig{
			Network: "test",
		},
	}

	authService := NewAuthService(cfg)

	testCases := []struct {
		name        string
		req         *RegisterRequest
		expectedErr string
	}{
		{
			name: "Invalid first name (numbers)",
			req: &RegisterRequest{
				FirstName: "John123",
				LastName:  "Doe",
				Email:     "john@example.com",
				Password:  "securepass123",
				Username:  "johndoe",
			},
			expectedErr: "first name must contain only alphabetic characters",
		},
		{
			name: "Invalid email format",
			req: &RegisterRequest{
				FirstName: "John",
				LastName:  "Doe",
				Email:     "invalid-email",
				Password:  "securepass123",
				Username:  "johndoe",
			},
			expectedErr: "invalid email format",
		},
		{
			name: "Password too short",
			req: &RegisterRequest{
				FirstName: "John",
				LastName:  "Doe",
				Email:     "john@example.com",
				Password:  "short",
				Username:  "johndoe",
			},
			expectedErr: "password must be at least 8 characters long",
		},
		{
			name: "Invalid mnemonic",
			req: &RegisterRequest{
				FirstName: "John",
				LastName:  "Doe",
				Email:     "john@example.com",
				Password:  "securepass123",
				Username:  "johndoe",
				Mnemonic:  "invalid mnemonic phrase",
			},
			expectedErr: "invalid mnemonic",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			response, err := authService.Register(tc.req)
			
			assert.Error(t, err)
			assert.Nil(t, response)
			assert.Contains(t, err.Error(), tc.expectedErr)
		})
	}
}

func TestAuthService_Login_Success(t *testing.T) {
	db := setupTestDB(t)
	defer func() {
		sqlDB, _ := db.DB()
		sqlDB.Close()
	}()

	cfg := &config.Config{
		JWT: config.JWTConfig{
			Secret: "test-secret-key-for-testing-only",
			Expiry: 24 * time.Hour,
		},
		TFGrid: config.TFGridConfig{
			Network: "test",
		},
	}

	authService := NewAuthService(cfg)

	// First register a user
	registerReq := &RegisterRequest{
		FirstName: "Test",
		LastName:  "User",
		Email:     "test@example.com",
		Password:  "testpassword123",
		Username:  "testuser",
	}

	_, err := authService.Register(registerReq)
	require.NoError(t, err)

	// Now test login
	loginReq := &LoginRequest{
		Email:    "test@example.com",
		Password: "testpassword123",
	}

	response, err := authService.Login(loginReq)
	
	assert.NoError(t, err)
	assert.NotNil(t, response)
	assert.True(t, response.Success)
	assert.NotEmpty(t, response.Token)
	assert.NotNil(t, response.User)
	assert.NotNil(t, response.WalletInfo)
	assert.Equal(t, "test@example.com", response.User.Email)
	assert.Equal(t, "testuser", response.User.Username)
}

func TestAuthService_Login_InvalidCredentials(t *testing.T) {
	db := setupTestDB(t)
	defer func() {
		sqlDB, _ := db.DB()
		sqlDB.Close()
	}()

	cfg := &config.Config{
		JWT: config.JWTConfig{
			Secret: "test-secret-key-for-testing-only",
			Expiry: 24 * time.Hour,
		},
		TFGrid: config.TFGridConfig{
			Network: "test",
		},
	}

	authService := NewAuthService(cfg)

	// Test login with non-existent user
	loginReq := &LoginRequest{
		Email:    "nonexistent@example.com",
		Password: "anypassword",
	}

	response, err := authService.Login(loginReq)
	
	assert.Error(t, err)
	assert.Nil(t, response)
	assert.Contains(t, err.Error(), "invalid email or password")
}

func TestAuthService_ValidateToken_Success(t *testing.T) {
	db := setupTestDB(t)
	defer func() {
		sqlDB, _ := db.DB()
		sqlDB.Close()
	}()

	cfg := &config.Config{
		JWT: config.JWTConfig{
			Secret: "test-secret-key-for-testing-only",
			Expiry: 24 * time.Hour,
		},
		TFGrid: config.TFGridConfig{
			Network: "test",
		},
	}

	authService := NewAuthService(cfg)

	// Register and login to get a valid token
	registerReq := &RegisterRequest{
		FirstName: "Token",
		LastName:  "Test",
		Email:     "token@example.com",
		Password:  "tokentest123",
		Username:  "tokentest",
	}

	registerResponse, err := authService.Register(registerReq)
	require.NoError(t, err)
	require.NotEmpty(t, registerResponse.Token)

	// Validate the token
	userProfile, err := authService.ValidateToken(registerResponse.Token)
	
	assert.NoError(t, err)
	assert.NotNil(t, userProfile)
	assert.Equal(t, "token@example.com", userProfile.Email)
	assert.Equal(t, "tokentest", userProfile.Username)
	assert.NotEmpty(t, userProfile.WalletAddress)
}

func TestAuthService_ValidateToken_InvalidToken(t *testing.T) {
	db := setupTestDB(t)
	defer func() {
		sqlDB, _ := db.DB()
		sqlDB.Close()
	}()

	cfg := &config.Config{
		JWT: config.JWTConfig{
			Secret: "test-secret-key-for-testing-only",
			Expiry: 24 * time.Hour,
		},
		TFGrid: config.TFGridConfig{
			Network: "test",
		},
	}

	authService := NewAuthService(cfg)

	// Test with invalid token
	userProfile, err := authService.ValidateToken("invalid.jwt.token")
	
	assert.Error(t, err)
	assert.Nil(t, userProfile)
	assert.Contains(t, err.Error(), "invalid token")
}
